# Copy-on-write строка

Реализуйте класс `CowString`, реализующий концепцию строки с копированием при изменении.

Идея copy-on-write заключается в том, что одинаковые строки могут ссылаться на одно и то же
внутреннее представление, экономя за счет этого память. При изменении строки прозрачно для
пользователя должна создаться копия внутреннего представления и изменение должно примениться к нему.

## Структура класса

Конструкторы:
- от `std::string_view`
- copy- и move-конструкторы

Методы и операторы:
- copy- и move- `operator=`
- `GetData`, возвращающий указатель на внутренний буффер `char*`
- `begin`/`end` в константном и не константном варианте (и соответствующие итераторы)
- `operator[]` и константный метод `At`
- операторы `+`, `+=`, `==`, `!=` от `CowString` и `std::string_view` в различных комбинациях
- оператор неявного приведения к `std::string_view`

Не забудьте про деструктор.

## Реализация

Данные строки должны храниться в буффере, выделяемом в динамической памяти. Использование умных указателей запрещено,
поэтому аккуратно управляйте памятью.

Потребуется реализовать дополнительный класс - внутреннее представление строки.

Внутреннее представление должно содержать счетчик ссылок. При создании новой строки создается внутреннее представление со счетчиком ссылок 1.

При копировании еще одна строка начинает ссылаться на существующее представление.
Соответственно, счетчик ссылок инкрементируется.

При удалении строки счетчик ссылок в её внутреннем представлении декрементируется.

Представление должно быть удалено, когда удаляется последняя строка, ссылающаяся на него.

При модификации строки, единолично владеющей своим внутренним представлением, создавать
новое представление не нужно.

Если потребовалось создать новое представление строки, все существующие итераторы
остаются валидными и "переключаются" на новое представление.

Для того чтобы отслеживать модификацию строки через итератор, оператор разыменования
неконстантного оператора должен возвращать не `char&`, а специальный прокси-объект, неявно
приводящийся к `char` с перегруженным оператором присваивания. Аналогичный прием надо применить
для `operator[]`.
